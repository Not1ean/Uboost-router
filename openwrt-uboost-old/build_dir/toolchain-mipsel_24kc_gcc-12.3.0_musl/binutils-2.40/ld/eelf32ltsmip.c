/* This file is is generated by a shell script.  DO NOT EDIT! */

/* 32 bit ELF emulation code for elf32ltsmip
   Copyright (C) 1991-2023 Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@cygnus.com>
   ELF support by Ian Lance Taylor <ian@cygnus.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_IS_elf32ltsmip

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "getopt.h"
#include "bfdlink.h"
#include "ctf-api.h"
#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "elf-bfd.h"
#include "ldelf.h"
#include "ldelfgen.h"

/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gldelf32ltsmip_before_parse (void);
static void gldelf32ltsmip_before_plugin_all_symbols_read
  (void);
static void gldelf32ltsmip_after_open (void);
static void gldelf32ltsmip_before_allocation (void);
static void gldelf32ltsmip_after_allocation (void);


#include "ldctor.h"
#include "elf/mips.h"
#include "elfxx-mips.h"

#define is_mips_elf(bfd)				  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	   && elf_tdata (bfd) != NULL				   && elf_object_id (bfd) == MIPS_ELF_DATA)

/* Fake input file for stubs.  */
static lang_input_statement_type *stub_file;
static bfd *stub_bfd;

static bool insn32;
static bool ignore_branch_isa;
static bool compact_branches;

struct hook_stub_info
{
  lang_statement_list_type add;
  asection *input_section;
};

/* Traverse the linker tree to find the spot where the stub goes.  */

static bool
hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)
{
  lang_statement_union_type *l;
  bool ret;

  for (; (l = *lp) != NULL; lp = &l->header.next)
    {
      switch (l->header.type)
	{
	case lang_constructors_statement_enum:
	  ret = hook_in_stub (info, &constructor_list.head);
	  if (ret)
	    return ret;
	  break;

	case lang_output_section_statement_enum:
	  ret = hook_in_stub (info,
			      &l->output_section_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_wild_statement_enum:
	  ret = hook_in_stub (info, &l->wild_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_group_statement_enum:
	  ret = hook_in_stub (info, &l->group_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_input_section_enum:
	  if (info->input_section == NULL
	      || l->input_section.section == info->input_section)
	    {
	      /* We've found our section.  Insert the stub immediately
		 before its associated input section.  */
	      *lp = info->add.head;
	      *(info->add.tail) = l;
	      return true;
	    }
	  break;

	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}
    }
  return false;
}

/* Create a new stub section called STUB_SEC_NAME and arrange for it to
   be linked in OUTPUT_SECTION.  The section should go at the beginning of
   OUTPUT_SECTION if INPUT_SECTION is null, otherwise it must go immediately
   before INPUT_SECTION.  */

static asection *
mips_add_stub_section (const char *stub_sec_name, asection *input_section,
		       asection *output_section)
{
  asection *stub_sec;
  flagword flags;
  lang_output_section_statement_type *os;
  struct hook_stub_info info;

  /* PR 12845: If the input section has been garbage collected it will
     not have its output section set to *ABS*.  */
  if (bfd_is_abs_section (output_section))
    return NULL;

  /* Create the stub file, if we haven't already.  */
  if (stub_file == NULL)
    {
      stub_file = lang_add_input_file ("linker stubs",
				       lang_input_file_is_fake_enum,
				       NULL);
      stub_bfd = bfd_create ("linker stubs", link_info.output_bfd);
      if (stub_bfd == NULL
	  || !bfd_set_arch_mach (stub_bfd,
				 bfd_get_arch (link_info.output_bfd),
				 bfd_get_mach (link_info.output_bfd)))
	{
	  einfo (_("%F%P: can not create BFD: %E\n"));
	  return NULL;
	}
      stub_bfd->flags |= BFD_LINKER_CREATED;
      stub_file->the_bfd = stub_bfd;
      ldlang_add_file (stub_file);
    }

  /* Create the section.  */
  stub_sec = bfd_make_section_anyway (stub_bfd, stub_sec_name);
  if (stub_sec == NULL)
    goto err_ret;

  /* Set the flags.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	   | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_KEEP);
  if (!bfd_set_section_flags (stub_sec, flags))
    goto err_ret;

  os = lang_output_section_get (output_section);

  /* Initialize a statement list that contains only the new statement.  */
  lang_list_init (&info.add);
  lang_add_section (&info.add, stub_sec, NULL, NULL, os);
  if (info.add.head == NULL)
    goto err_ret;

  /* Insert the new statement in the appropriate place.  */
  info.input_section = input_section;
  if (hook_in_stub (&info, &os->children.head))
    return stub_sec;

 err_ret:
  einfo (_("%X%P: can not make stub section: %E\n"));
  return NULL;
}

/* This is called before the input files are opened.  */

static void
mips_create_output_section_statements (void)
{
  struct elf_link_hash_table *htab;

  htab = elf_hash_table (&link_info);
  if (is_elf_hash_table (&htab->root) && is_mips_elf (link_info.output_bfd))
    _bfd_mips_elf_linker_flags (&link_info, insn32, ignore_branch_isa,
				false);

  if (is_mips_elf (link_info.output_bfd))
    {
      _bfd_mips_elf_compact_branches (&link_info, compact_branches);
      _bfd_mips_elf_init_stubs (&link_info, mips_add_stub_section);
    }
}

/* This is called after we have merged the private data of the input bfds.  */

static void
mips_before_allocation (void)
{
  if (is_mips_elf (link_info.output_bfd))
    {
      flagword flags;

      flags = elf_elfheader (link_info.output_bfd)->e_flags;
      if (!bfd_link_pic (&link_info)
	  && !link_info.nocopyreloc
	  && (flags & (EF_MIPS_PIC | EF_MIPS_CPIC)) == EF_MIPS_CPIC)
	_bfd_mips_elf_use_plts_and_copy_relocs (&link_info);
    }

  gldelf32ltsmip_before_allocation ();
}


static void
gldelf32ltsmip_before_parse (void)
{
  ldfile_set_output_arch ("mips", bfd_arch_mips);
  input_flags.dynamic = true;
  config.has_shared = true;
  config.separate_code = false;
  link_info.check_relocs_after_open_input = true;
  link_info.relro = DEFAULT_LD_Z_RELRO;
  link_info.separate_code = DEFAULT_LD_Z_SEPARATE_CODE;
  link_info.warn_execstack = DEFAULT_LD_WARN_EXECSTACK;
  link_info.no_warn_rwx_segments = ! DEFAULT_LD_WARN_RWX_SEGMENTS;
  link_info.default_execstack = DEFAULT_LD_EXECSTACK;
}


/* These variables are used to implement target options */

static char *audit; /* colon (typically) separated list of libs */
static char *depaudit; /* colon (typically) separated list of libs */


/* This is called before calling plugin 'all symbols read' hook.  */

static void
gldelf32ltsmip_before_plugin_all_symbols_read (void)
{
  ldelf_before_plugin_all_symbols_read (true, false,
				        true,
					false,
					32, "/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl");
}

/* This is called after all the input files have been opened.  */

static void
gldelf32ltsmip_after_open (void)
{
  ldelf_after_open (true, false,
		    true, false, 32, "/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl");
}


/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gldelf32ltsmip_before_allocation (void)
{
  ldelf_before_allocation (audit, depaudit, NULL);
}


static void
gldelf32ltsmip_after_allocation (void)
{
  int need_layout = bfd_elf_discard_info (link_info.output_bfd, &link_info);

  if (need_layout < 0)
    einfo (_("%X%P: .eh_frame/.stab edit: %E\n"));
  else
    ldelf_map_segments (need_layout);
}

static char *
gldelf32ltsmip_get_script (int *isfile)
{
  *isfile = 0;

  if (bfd_link_relocatable (&link_info) && config.build_constructors)
    return
"/* Script for -Ur */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
 /* For some reason, the Solaris linker makes bad executables\n\
  if gld -r is used and the intermediate file has sections starting\n\
  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n\
  bug.  But for now assigning the zero vmas works.  */\n\
SECTIONS\n\
{\n\
  .interp       0 : { *(.interp) }\n\
  .MIPS.abiflags 0 : { *(.MIPS.abiflags) }\n\
  .reginfo       0 : { *(.reginfo) }\n\
  .MIPS.xhash    0 : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id 0: { *(.note.gnu.build-id) }\n\
  .dynamic      0 : { *(.dynamic) }\n\
  .hash         0 : { *(.hash) }\n\
  .gnu.hash     0 : { *(.gnu.hash) }\n\
  .dynsym       0 : { *(.dynsym) }\n\
  .dynstr       0 : { *(.dynstr) }\n\
  .gnu.version  0 : { *(.gnu.version) }\n"
"  .gnu.version_d 0: { *(.gnu.version_d) }\n\
  .gnu.version_r 0: { *(.gnu.version_r) }\n\
  .rel.init     0 : { *(.rel.init) }\n\
  .rela.init    0 : { *(.rela.init) }\n\
  .rel.text     0 : { *(.rel.text) }\n\
  .rela.text    0 : { *(.rela.text) }\n\
  .rel.fini     0 : { *(.rel.fini) }\n\
  .rela.fini    0 : { *(.rela.fini) }\n\
  .rel.rodata   0 : { *(.rel.rodata) }\n\
  .rela.rodata  0 : { *(.rela.rodata) }\n\
  .rel.data.rel.ro 0 : { *(.rel.data.rel.ro) }\n\
  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n\
  .rel.data     0 : { *(.rel.data) }\n\
  .rela.data    0 : { *(.rela.data) }\n\
  .rel.tdata	0 : { *(.rel.tdata) }\n\
  .rela.tdata	0 : { *(.rela.tdata) }\n\
  .rel.tbss	0 : { *(.rel.tbss) }\n\
  .rela.tbss	0 : { *(.rela.tbss) }\n\
  .rel.ctors    0 : { *(.rel.ctors) }\n\
  .rela.ctors   0 : { *(.rela.ctors) }\n\
  .rel.dtors    0 : { *(.rel.dtors) }\n\
  .rela.dtors   0 : { *(.rela.dtors) }\n\
  .rel.got      0 : { *(.rel.got) }\n\
  .rela.got     0 : { *(.rela.got) }\n\
  .rel.dyn      0 : { *(.rel.dyn) }\n"
"  .rel.sdata    0 : { *(.rel.sdata) }\n\
  .rela.sdata   0 : { *(.rela.sdata) }\n\
  .rel.sbss     0 : { *(.rel.sbss) }\n\
  .rela.sbss    0 : { *(.rela.sbss) }\n\
  .rel.sdata2   0 : { *(.rel.sdata2) }\n\
  .rela.sdata2  0 : { *(.rela.sdata2) }\n\
  .rel.sbss2    0 : { *(.rel.sbss2) }\n\
  .rela.sbss2   0 : { *(.rela.sbss2) }\n\
  .rel.bss      0 : { *(.rel.bss) }\n\
  .rela.bss     0 : { *(.rela.bss) }\n\
  .rel.iplt     0 :\n\
    {\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.iplt    0 :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt      0 :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt     0 :\n\
    {\n\
      *(.rela.plt)\n"
"    }\n\
  .init         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text         0 :\n\
  {\n\
    *(.text .stub)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  }\n\
  .fini         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  .rodata       0 : { *(.rodata) }\n\
  .rodata1      0 : { *(.rodata1) }\n\
  .sdata2       0 :\n\
  {\n\
    *(.sdata2)\n\
  }\n\
  .sbss2        0 : { *(.sbss2) }\n\
  .eh_frame_hdr 0 : { *(.eh_frame_hdr) }\n\
  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .sframe       0 : ONLY_IF_RO { *(.sframe) }\n"
"  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table) }\n\
  .gnu_extab 0 : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges 0 : ONLY_IF_RO { *(.exception_ranges) }\n\
  .plt          0 : { *(.plt) }\n\
  .iplt         0 : { *(.iplt) }\n\
  /* Exception handling  */\n\
  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .sframe       0 : ONLY_IF_RW { *(.sframe) }\n\
  .gnu_extab    0 : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table) }\n\
  .exception_ranges 0 : ONLY_IF_RW { *(.exception_ranges) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	0 :\n\
   {\n\
     *(.tdata)\n\
   }\n\
  .tbss		0 : { *(.tbss) }\n\
  .jcr          0 : { KEEP (*(.jcr)) }\n\
  .got.plt      0 : { *(.got.plt) }\n\
  .data         0 :\n\
  {\n\
    *(.data)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1        0 : { *(.data1) }\n\
  .got          0 : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata        0 :\n\
  {\n\
    *(.sdata)\n\
  }\n\
  .lit8         0 : { *(.lit8) }\n\
  .lit4         0 : { *(.lit4) }\n\
  .sbss         0 :\n\
  {\n\
    *(.sbss)\n\
  }\n\
  .bss          0 :\n\
  {\n\
   *(.bss)\n\
  }\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
}\n\n"
  ; else if (bfd_link_relocatable (&link_info)) return
"/* Script for -r */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
 /* For some reason, the Solaris linker makes bad executables\n\
  if gld -r is used and the intermediate file has sections starting\n\
  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld\n\
  bug.  But for now assigning the zero vmas works.  */\n\
SECTIONS\n\
{\n\
  .interp       0 : { *(.interp) }\n\
  .MIPS.abiflags 0 : { *(.MIPS.abiflags) }\n\
  .reginfo       0 : { *(.reginfo) }\n\
  .MIPS.xhash    0 : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id 0: { *(.note.gnu.build-id) }\n\
  .dynamic      0 : { *(.dynamic) }\n\
  .hash         0 : { *(.hash) }\n\
  .gnu.hash     0 : { *(.gnu.hash) }\n\
  .dynsym       0 : { *(.dynsym) }\n\
  .dynstr       0 : { *(.dynstr) }\n\
  .gnu.version  0 : { *(.gnu.version) }\n"
"  .gnu.version_d 0: { *(.gnu.version_d) }\n\
  .gnu.version_r 0: { *(.gnu.version_r) }\n\
  .rel.init     0 : { *(.rel.init) }\n\
  .rela.init    0 : { *(.rela.init) }\n\
  .rel.text     0 : { *(.rel.text) }\n\
  .rela.text    0 : { *(.rela.text) }\n\
  .rel.fini     0 : { *(.rel.fini) }\n\
  .rela.fini    0 : { *(.rela.fini) }\n\
  .rel.rodata   0 : { *(.rel.rodata) }\n\
  .rela.rodata  0 : { *(.rela.rodata) }\n\
  .rel.data.rel.ro 0 : { *(.rel.data.rel.ro) }\n\
  .rela.data.rel.ro 0 : { *(.rela.data.rel.ro) }\n\
  .rel.data     0 : { *(.rel.data) }\n\
  .rela.data    0 : { *(.rela.data) }\n\
  .rel.tdata	0 : { *(.rel.tdata) }\n\
  .rela.tdata	0 : { *(.rela.tdata) }\n\
  .rel.tbss	0 : { *(.rel.tbss) }\n\
  .rela.tbss	0 : { *(.rela.tbss) }\n\
  .rel.ctors    0 : { *(.rel.ctors) }\n\
  .rela.ctors   0 : { *(.rela.ctors) }\n\
  .rel.dtors    0 : { *(.rel.dtors) }\n\
  .rela.dtors   0 : { *(.rela.dtors) }\n\
  .rel.got      0 : { *(.rel.got) }\n\
  .rela.got     0 : { *(.rela.got) }\n\
  .rel.dyn      0 : { *(.rel.dyn) }\n"
"  .rel.sdata    0 : { *(.rel.sdata) }\n\
  .rela.sdata   0 : { *(.rela.sdata) }\n\
  .rel.sbss     0 : { *(.rel.sbss) }\n\
  .rela.sbss    0 : { *(.rela.sbss) }\n\
  .rel.sdata2   0 : { *(.rel.sdata2) }\n\
  .rela.sdata2  0 : { *(.rela.sdata2) }\n\
  .rel.sbss2    0 : { *(.rel.sbss2) }\n\
  .rela.sbss2   0 : { *(.rela.sbss2) }\n\
  .rel.bss      0 : { *(.rel.bss) }\n\
  .rela.bss     0 : { *(.rela.bss) }\n\
  .rel.iplt     0 :\n\
    {\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.iplt    0 :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt      0 :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt     0 :\n\
    {\n\
      *(.rela.plt)\n"
"    }\n\
  .init         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text         0 :\n\
  {\n\
    *(.text .stub)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
  }\n\
  .fini         0 :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  .rodata       0 : { *(.rodata) }\n\
  .rodata1      0 : { *(.rodata1) }\n\
  .sdata2       0 :\n\
  {\n\
    *(.sdata2)\n\
  }\n\
  .sbss2        0 : { *(.sbss2) }\n\
  .eh_frame_hdr 0 : { *(.eh_frame_hdr) }\n\
  .eh_frame     0 : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n\
  .sframe       0 : ONLY_IF_RO { *(.sframe) }\n"
"  .gcc_except_table 0 : ONLY_IF_RO { *(.gcc_except_table) }\n\
  .gnu_extab 0 : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges 0 : ONLY_IF_RO { *(.exception_ranges) }\n\
  .plt          0 : { *(.plt) }\n\
  .iplt         0 : { *(.iplt) }\n\
  /* Exception handling  */\n\
  .eh_frame     0 : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n\
  .sframe       0 : ONLY_IF_RW { *(.sframe) }\n\
  .gnu_extab    0 : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table 0 : ONLY_IF_RW { *(.gcc_except_table) }\n\
  .exception_ranges 0 : ONLY_IF_RW { *(.exception_ranges) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	0 :\n\
   {\n\
     *(.tdata)\n\
   }\n\
  .tbss		0 : { *(.tbss) }\n\
  .jcr          0 : { KEEP (*(.jcr)) }\n\
  .got.plt      0 : { *(.got.plt) }\n\
  .data         0 :\n\
  {\n\
    *(.data)\n\
  }\n\
  .data1        0 : { *(.data1) }\n\
  .got          0 : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata        0 :\n\
  {\n\
    *(.sdata)\n\
  }\n\
  .lit8         0 : { *(.lit8) }\n\
  .lit4         0 : { *(.lit4) }\n\
  .sbss         0 :\n\
  {\n\
    *(.sbss)\n\
  }\n\
  .bss          0 :\n\
  {\n\
   *(.bss)\n\
  }\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
}\n\n"
  ; else if (!config.text_read_only) return
"/* Script for -N */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n"
"  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n"
"    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n"
"  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = .;\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (!config.magic_demand_paged) return
"/* Script for -n */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n"
"  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n"
"    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n"
"  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.combreloc
             && link_info.separate_code
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -pie -z combreloc -z separate-code -z relro -z now */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.combreloc
             && link_info.relro
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -pie -z combreloc -z relro -z now */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n"
"      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n"
"  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n"
"  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.separate_code
             && link_info.combreloc) return
"/* Script for -pie -z combreloc -z separate-code */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.combreloc) return
"/* Script for -pie -z combreloc */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n"
"      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n"
"  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n"
"  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)
             && link_info.separate_code) return
"/* Script for -pie -z separate-code */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n"
"  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n"
"  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n"
"  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_pie (&link_info)) return
"/* Script for -pie */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0)); . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n"
"  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n"
"    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n"
"  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc
             && link_info.separate_code
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -shared -z combreloc -z separate-code -z relro -z now */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n"
"  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"
"      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n"
"  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    PROVIDE (_ftext = .);\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n"
"     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    PROVIDE (_fdata = .);\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  PROVIDE (_fbss = .);\n\
  .sbss           :\n\
  {\n\
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc
             && link_info.relro
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -shared -z combreloc -z relro -z now */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n"
"  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    PROVIDE (_ftext = .);\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n"
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    PROVIDE (_fdata = .);\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  PROVIDE (_fbss = .);\n\
  .sbss           :\n\
  {\n\
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc
             && link_info.separate_code) return
"/* Script for -shared -z combreloc -z separate-code */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n"
"  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n"
"      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n"
"  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    PROVIDE (_ftext = .);\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n"
"     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    PROVIDE (_fdata = .);\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  PROVIDE (_fbss = .);\n\
  .sbss           :\n\
  {\n\
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.combreloc) return
"/* Script for -shared -z combreloc */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n"
"      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n"
"  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    PROVIDE (_ftext = .);\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n"
"  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    PROVIDE (_fdata = .);\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  PROVIDE (_fbss = .);\n\
  .sbss           :\n\
  {\n\
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)
             && link_info.separate_code) return
"/* Script for -shared -z separate-code */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n"
"  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n"
"  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    PROVIDE (_ftext = .);\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n"
"  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    PROVIDE (_fdata = .);\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  PROVIDE (_fbss = .);\n\
  .sbss           :\n\
  {\n\
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (bfd_link_dll (&link_info)) return
"/* Script for -shared */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  . = SEGMENT_START(\"text-segment\", 0) + SIZEOF_HEADERS;\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n"
"  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      *(.rel.iplt)\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      *(.rela.iplt)\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n"
"  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    PROVIDE (_ftext = .);\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n"
"  .rodata1        : { *(.rodata1) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    KEEP (*(.preinit_array))\n\
  }\n\
  .init_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
  }\n\
  .fini_array    :\n\
  {\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    PROVIDE (_fdata = .);\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  PROVIDE (_edata = .); PROVIDE (edata = .);\n\
  . = .;\n\
  PROVIDE (__bss_start = .);\n\
  PROVIDE (_fbss = .);\n\
  .sbss           :\n\
  {\n\
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  PROVIDE (_end = .); PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc
             && link_info.separate_code
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -z combreloc -z separate-code -z relro -z now */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n\
  .rela.dyn       :\n"
"    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n"
"    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n"
"  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc
             && link_info.relro
             && (link_info.flags & DF_BIND_NOW)) return
"/* Script for -z combreloc -z relro -z now */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n"
"  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n"
"  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n"
"  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  .got.plt        : { *(.got.plt) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc
             && link_info.separate_code) return
"/* Script for -z combreloc -z separate-code */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n\
  .rela.dyn       :\n"
"    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n\
  .rela.plt       :\n"
"    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n"
"  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.combreloc) return
"/* Script for -z combreloc */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.dyn        :\n\
    {\n\
      *(.rel.init)\n\
      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n\
      *(.rel.fini)\n\
      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n\
      *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)\n\
      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n\
      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n\
      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n\
      *(.rel.ctors)\n\
      *(.rel.dtors)\n\
      *(.rel.got)\n\
      *(.rel.dyn)\n\
      *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)\n\
      *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)\n\
      *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)\n\
      *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)\n\
      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n"
"  .rela.dyn       :\n\
    {\n\
      *(.rela.init)\n\
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n\
      *(.rela.fini)\n\
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n\
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n\
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n\
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n\
      *(.rela.ctors)\n\
      *(.rela.dtors)\n\
      *(.rela.got)\n\
      *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)\n\
      *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)\n\
      *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)\n\
      *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)\n\
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n"
"  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n\
  }\n"
"  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else if (link_info.separate_code) return
"/* Script for -z separate-code */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n\
  .gnu.version_d  : { *(.gnu.version_d) }\n"
"  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n\
  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n"
"  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n\
    }\n"
"  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n"
"  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  . = ALIGN(CONSTANT (MAXPAGESIZE));\n\
  /* Adjust the address for the rodata segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = SEGMENT_START(\"rodata-segment\", ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)));\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
  ; else return
"/* Default linker script, for normal executables */\n\
/* Copyright (C) 2014-2023 Free Software Foundation, Inc.\n\
   Copying and distribution of this script, with or without modification,\n\
   are permitted in any medium without royalty provided the copyright\n\
   notice and this notice are preserved.  */\n\
OUTPUT_FORMAT(\"elf32-tradlittlemips\", \"elf32-tradbigmips\",\n\
	      \"elf32-tradlittlemips\")\n\
OUTPUT_ARCH(mips)\n\
ENTRY(__start)\n\
SEARCH_DIR(\"=/home/notlean/openwrt-uboost/staging_dir/toolchain-mipsel_24kc_gcc-12.3.0_musl/mipsel-openwrt-linux-musl/lib\"); SEARCH_DIR(\"=/usr/local/lib\"); SEARCH_DIR(\"=/lib\"); SEARCH_DIR(\"=/usr/lib\");\n\
SECTIONS\n\
{\n\
  /* Read-only sections, merged into text segment: */\n\
  PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x0400000)); . = SEGMENT_START(\"text-segment\", 0x0400000) + SIZEOF_HEADERS;\n\
  .interp         : { *(.interp) }\n\
  .MIPS.abiflags   : { *(.MIPS.abiflags) }\n\
  .reginfo         : { *(.reginfo) }\n\
  .MIPS.xhash      : { *(.MIPS.xhash) }\n\
  .note.gnu.build-id  : { *(.note.gnu.build-id) }\n\
  .dynamic        : { *(.dynamic) }\n\
  .hash           : { *(.hash) }\n\
  .gnu.hash       : { *(.gnu.hash) }\n\
  .dynsym         : { *(.dynsym) }\n\
  .dynstr         : { *(.dynstr) }\n\
  .gnu.version    : { *(.gnu.version) }\n"
"  .gnu.version_d  : { *(.gnu.version_d) }\n\
  .gnu.version_r  : { *(.gnu.version_r) }\n\
  .rel.init       : { *(.rel.init) }\n\
  .rela.init      : { *(.rela.init) }\n\
  .rel.text       : { *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*) }\n\
  .rela.text      : { *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) }\n\
  .rel.fini       : { *(.rel.fini) }\n\
  .rela.fini      : { *(.rela.fini) }\n\
  .rel.rodata     : { *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*) }\n\
  .rela.rodata    : { *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) }\n\
  .rel.data.rel.ro   : { *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*) }\n\
  .rela.data.rel.ro   : { *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) }\n\
  .rel.data       : { *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*) }\n\
  .rela.data      : { *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) }\n\
  .rel.tdata	  : { *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*) }\n\
  .rela.tdata	  : { *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) }\n\
  .rel.tbss	  : { *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*) }\n\
  .rela.tbss	  : { *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) }\n\
  .rel.ctors      : { *(.rel.ctors) }\n\
  .rela.ctors     : { *(.rela.ctors) }\n\
  .rel.dtors      : { *(.rel.dtors) }\n\
  .rela.dtors     : { *(.rela.dtors) }\n\
  .rel.got        : { *(.rel.got) }\n\
  .rela.got       : { *(.rela.got) }\n\
  .rel.dyn        : { *(.rel.dyn) }\n"
"  .rel.sdata      : { *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*) }\n\
  .rela.sdata     : { *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*) }\n\
  .rel.sbss       : { *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*) }\n\
  .rela.sbss      : { *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*) }\n\
  .rel.sdata2     : { *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*) }\n\
  .rela.sdata2    : { *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*) }\n\
  .rel.sbss2      : { *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*) }\n\
  .rela.sbss2     : { *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*) }\n\
  .rel.bss        : { *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*) }\n\
  .rela.bss       : { *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) }\n\
  .rel.iplt       :\n\
    {\n\
      PROVIDE_HIDDEN (__rel_iplt_start = .);\n\
      *(.rel.iplt)\n\
      PROVIDE_HIDDEN (__rel_iplt_end = .);\n\
    }\n\
  .rela.iplt      :\n\
    {\n\
      PROVIDE_HIDDEN (__rela_iplt_start = .);\n\
      *(.rela.iplt)\n\
      PROVIDE_HIDDEN (__rela_iplt_end = .);\n\
    }\n\
  .rel.plt        :\n\
    {\n\
      *(.rel.plt)\n"
"    }\n\
  .rela.plt       :\n\
    {\n\
      *(.rela.plt)\n\
    }\n\
  .init           :\n\
  {\n\
    KEEP (*(SORT_NONE(.init)))\n\
  }\n\
  .text           :\n\
  {\n\
    _ftext = .;\n\
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)\n\
    *(.text.exit .text.exit.*)\n\
    *(.text.startup .text.startup.*)\n\
    *(.text.hot .text.hot.*)\n\
    *(SORT(.text.sorted.*))\n\
    *(.text .stub .text.* .gnu.linkonce.t.*)\n\
    /* .gnu.warning sections are handled specially by elf.em.  */\n\
    *(.gnu.warning)\n\
    *(.mips16.fn.*) *(.mips16.call.*)\n\
  }\n\
  .fini           :\n\
  {\n\
    KEEP (*(SORT_NONE(.fini)))\n"
"  }\n\
  PROVIDE (__etext = .);\n\
  PROVIDE (_etext = .);\n\
  PROVIDE (etext = .);\n\
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n\
  .rodata1        : { *(.rodata1) }\n\
  .sdata2         :\n\
  {\n\
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)\n\
  }\n\
  .sbss2          : { *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*) }\n\
  .eh_frame_hdr   : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }\n\
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RO { *(.sframe) *(.sframe.*) }\n\
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*) }\n\
  .gnu_extab   : ONLY_IF_RO { *(.gnu_extab*) }\n\
  /* These sections are generated by the Sun/Oracle C++ compiler.  */\n\
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges*) }\n\
  .plt            : { *(.plt) }\n\
  .iplt           : { *(.iplt) }\n\
  /* Adjust the address for the data segment.  We want to adjust up to\n\
     the same address within the page on the next page up.  */\n\
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));\n\
  /* Exception handling  */\n\
  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*) }\n\
  .sframe         : ONLY_IF_RW { *(.sframe) *(.sframe.*) }\n\
  .gnu_extab      : ONLY_IF_RW { *(.gnu_extab) }\n\
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }\n\
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*) }\n\
  /* Thread Local Storage sections  */\n\
  .tdata	  :\n\
   {\n\
     PROVIDE_HIDDEN (__tdata_start = .);\n\
     *(.tdata .tdata.* .gnu.linkonce.td.*)\n\
   }\n\
  .tbss		  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n\
  .preinit_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__preinit_array_start = .);\n\
    KEEP (*(.preinit_array))\n\
    PROVIDE_HIDDEN (__preinit_array_end = .);\n\
  }\n\
  .init_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__init_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))\n\
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))\n\
    PROVIDE_HIDDEN (__init_array_end = .);\n\
  }\n\
  .fini_array    :\n\
  {\n\
    PROVIDE_HIDDEN (__fini_array_start = .);\n\
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))\n\
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))\n\
    PROVIDE_HIDDEN (__fini_array_end = .);\n\
  }\n\
  .ctors          :\n\
  {\n\
    /* gcc uses crtbegin.o to find the start of\n\
       the constructors, so we make sure it is\n\
       first.  Because this is a wildcard, it\n\
       doesn't matter if the user does not\n\
       actually link against crtbegin.o; the\n\
       linker won't look for a file to match a\n\
       wildcard.  The wildcard also means that it\n\
       doesn't matter which directory crtbegin.o\n\
       is in.  */\n\
    KEEP (*crtbegin.o(.ctors))\n\
    KEEP (*crtbegin?.o(.ctors))\n\
    /* We don't want to include the .ctor section from\n\
       the crtend.o file until after the sorted ctors.\n\
       The .ctor section from the crtend file contains the\n\
       end of ctors marker and it must be last */\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))\n\
    KEEP (*(SORT(.ctors.*)))\n\
    KEEP (*(.ctors))\n\
  }\n\
  .dtors          :\n\
  {\n\
    KEEP (*crtbegin.o(.dtors))\n\
    KEEP (*crtbegin?.o(.dtors))\n\
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))\n\
    KEEP (*(SORT(.dtors.*)))\n\
    KEEP (*(.dtors))\n\
  }\n\
  .jcr            : { KEEP (*(.jcr)) }\n\
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }\n\
  . = DATA_SEGMENT_RELRO_END (0, .);\n\
  .got.plt        : { *(.got.plt) }\n\
  .data           :\n\
  {\n\
    _fdata = .;\n\
    *(.data .data.* .gnu.linkonce.d.*)\n\
    SORT(CONSTRUCTORS)\n\
  }\n\
  .data1          : { *(.data1) }\n\
  . = .; HIDDEN (_gp = ALIGN (16) + 0x7ff0);\n\
  .got            : { *(.got) }\n\
  /* We want the small data sections together, so single-instruction offsets\n\
     can access them all, and initialized data all before uninitialized, so\n\
     we can shorten the on-disk segment size.  */\n\
  .sdata          :\n\
  {\n\
    *(.sdata .sdata.* .gnu.linkonce.s.*)\n\
  }\n\
  .lit8           : { *(.lit8) }\n\
  .lit4           : { *(.lit4) }\n\
  _edata = .; PROVIDE (edata = .);\n\
  . = .;\n\
  __bss_start = .;\n\
  _fbss = .;\n\
  .sbss           :\n\
  {\n\
    *(.dynsbss)\n\
    *(.sbss .sbss.* .gnu.linkonce.sb.*)\n\
    *(.scommon)\n\
  }\n\
  .bss            :\n\
  {\n\
   *(.dynbss)\n\
   *(.bss .bss.* .gnu.linkonce.b.*)\n\
   *(COMMON)\n\
   /* Align here to ensure that the .bss section occupies space up to\n\
      _end.  Align after .bss to ensure correct alignment even if the\n\
      .bss section disappears because there are no input sections.\n\
      FIXME: Why do we need it? When there is no .bss section, we do not\n\
      pad the .data section.  */\n\
   . = ALIGN(. != 0 ? 32 / 8 : 1);\n\
  }\n\
  . = ALIGN(32 / 8);\n\
  . = SEGMENT_START(\"ldata-segment\", .);\n\
  . = ALIGN(32 / 8);\n\
  _end = .; PROVIDE (end = .);\n\
  . = DATA_SEGMENT_END (.);\n\
  /* Stabs debugging sections.  */\n\
  .stab          0 : { *(.stab) }\n\
  .stabstr       0 : { *(.stabstr) }\n\
  .stab.excl     0 : { *(.stab.excl) }\n\
  .stab.exclstr  0 : { *(.stab.exclstr) }\n\
  .stab.index    0 : { *(.stab.index) }\n\
  .stab.indexstr 0 : { *(.stab.indexstr) }\n\
  .comment       0 : { *(.comment) }\n\
  .gnu.build.attributes : { *(.gnu.build.attributes .gnu.build.attributes.*) }\n\
  /* DWARF debug sections.\n\
     Symbols in the DWARF debugging sections are relative to the beginning\n\
     of the section so we begin them at 0.  */\n\
  /* DWARF 1.  */\n\
  .debug          0 : { *(.debug) }\n\
  .line           0 : { *(.line) }\n\
  /* GNU DWARF 1 extensions.  */\n\
  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n\
  .debug_sfnames  0 : { *(.debug_sfnames) }\n\
  /* DWARF 1.1 and DWARF 2.  */\n\
  .debug_aranges  0 : { *(.debug_aranges) }\n\
  .debug_pubnames 0 : { *(.debug_pubnames) }\n\
  /* DWARF 2.  */\n\
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n\
  .debug_abbrev   0 : { *(.debug_abbrev) }\n\
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end) }\n\
  .debug_frame    0 : { *(.debug_frame) }\n\
  .debug_str      0 : { *(.debug_str) }\n\
  .debug_loc      0 : { *(.debug_loc) }\n\
  .debug_macinfo  0 : { *(.debug_macinfo) }\n\
  /* SGI/MIPS DWARF 2 extensions.  */\n\
  .debug_weaknames 0 : { *(.debug_weaknames) }\n\
  .debug_funcnames 0 : { *(.debug_funcnames) }\n\
  .debug_typenames 0 : { *(.debug_typenames) }\n\
  .debug_varnames  0 : { *(.debug_varnames) }\n\
  /* DWARF 3.  */\n\
  .debug_pubtypes 0 : { *(.debug_pubtypes) }\n\
  .debug_ranges   0 : { *(.debug_ranges) }\n\
  /* DWARF 5.  */\n\
  .debug_addr     0 : { *(.debug_addr) }\n\
  .debug_line_str 0 : { *(.debug_line_str) }\n\
  .debug_loclists 0 : { *(.debug_loclists) }\n\
  .debug_macro    0 : { *(.debug_macro) }\n\
  .debug_names    0 : { *(.debug_names) }\n\
  .debug_rnglists 0 : { *(.debug_rnglists) }\n\
  .debug_str_offsets 0 : { *(.debug_str_offsets) }\n\
  .debug_sup      0 : { *(.debug_sup) }\n\
  .gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }\n\
  .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }\n\
  .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }\n\
  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }\n\
  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }\n\
  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }\n\
  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }\n\
  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }\n\
  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }\n\
  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }\n\
  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }\n\
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }\n\
}\n\n"
; }
 
enum
  {
    OPTION_INSN32 = 301,
    OPTION_NO_INSN32,
    OPTION_IGNORE_BRANCH_ISA,
    OPTION_NO_IGNORE_BRANCH_ISA,
    OPTION_COMPACT_BRANCHES,
    OPTION_NO_COMPACT_BRANCHES
  };


enum elf_options
{
  OPTION_DISABLE_NEW_DTAGS = 400,
  OPTION_ENABLE_NEW_DTAGS,
  OPTION_GROUP,
  OPTION_EH_FRAME_HDR,
  OPTION_NO_EH_FRAME_HDR,
  OPTION_EXCLUDE_LIBS,
  OPTION_HASH_STYLE,
  OPTION_BUILD_ID,
  OPTION_PACKAGE_METADATA,
  OPTION_AUDIT,
  OPTION_COMPRESS_DEBUG
};

static void
gldelf32ltsmip_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const char xtra_short[] = "z:P:";
  static const struct option xtra_long[] = {
    {"audit", required_argument, NULL, OPTION_AUDIT},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
    {"build-id", optional_argument, NULL, OPTION_BUILD_ID},
    {"package-metadata", optional_argument, NULL, OPTION_PACKAGE_METADATA},
    {"compress-debug-sections", required_argument, NULL, OPTION_COMPRESS_DEBUG},
    {"depaudit", required_argument, NULL, 'P'},
    {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
    {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
    {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
    {"no-eh-frame-hdr", no_argument, NULL, OPTION_NO_EH_FRAME_HDR},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"hash-style", required_argument, NULL, OPTION_HASH_STYLE},
    
  { "insn32", no_argument, NULL, OPTION_INSN32 },
  { "no-insn32", no_argument, NULL, OPTION_NO_INSN32 },
  { "ignore-branch-isa", no_argument, NULL, OPTION_IGNORE_BRANCH_ISA },
  { "no-ignore-branch-isa", no_argument, NULL, OPTION_NO_IGNORE_BRANCH_ISA },
  { "compact-branches", no_argument, NULL, OPTION_COMPACT_BRANCHES },
  { "no-compact-branches", no_argument, NULL, OPTION_NO_COMPACT_BRANCHES },

    {NULL, no_argument, NULL, 0}
  };

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

#define DEFAULT_BUILD_ID_STYLE	"sha1"

static bool
gldelf32ltsmip_handle_option (int optc)
{
  switch (optc)
    {
    default:
      return false;

    case OPTION_BUILD_ID:
      free ((char *) ldelf_emit_note_gnu_build_id);
      ldelf_emit_note_gnu_build_id = NULL;
      if (optarg == NULL)
	optarg = DEFAULT_BUILD_ID_STYLE;
      if (strcmp (optarg, "none"))
	ldelf_emit_note_gnu_build_id = xstrdup (optarg);
      break;

    case OPTION_PACKAGE_METADATA:
      free ((char *) ldelf_emit_note_fdo_package_metadata);
      ldelf_emit_note_fdo_package_metadata = NULL;
      if (optarg != NULL && strlen(optarg) > 0)
	ldelf_emit_note_fdo_package_metadata = xstrdup (optarg);
      break;

    case OPTION_COMPRESS_DEBUG:
      config.compress_debug = bfd_get_compression_algorithm (optarg);
      if (strcasecmp (optarg, "zstd") == 0)
	{
#ifndef HAVE_ZSTD
	  if (config.compress_debug == COMPRESS_DEBUG_ZSTD)
	    einfo (_ ("%F%P: --compress-debug-sections=zstd: ld is not built "
		  "with zstd support\n"));
#endif
	}
      if (config.compress_debug == COMPRESS_UNKNOWN)
	einfo (_("%F%P: invalid --compress-debug-sections option: `%s'\n"),
	       optarg);
      break;
    case OPTION_AUDIT:
	ldelf_append_to_separated_string (&audit, optarg);
	break;

    case 'P':
	ldelf_append_to_separated_string (&depaudit, optarg);
	break;

    case OPTION_DISABLE_NEW_DTAGS:
      link_info.new_dtags = false;
      break;

    case OPTION_ENABLE_NEW_DTAGS:
      link_info.new_dtags = true;
      break;

    case OPTION_EH_FRAME_HDR:
      link_info.eh_frame_hdr_type = DWARF2_EH_HDR;
      break;

    case OPTION_NO_EH_FRAME_HDR:
      link_info.eh_frame_hdr_type = 0;
      break;

    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.unresolved_syms_in_objects = RM_DIAGNOSE;
      link_info.unresolved_syms_in_shared_libs = RM_DIAGNOSE;
      break;

    case OPTION_EXCLUDE_LIBS:
      add_excluded_libs (optarg);
      break;

    case OPTION_HASH_STYLE:
      link_info.emit_hash = false;
      link_info.emit_gnu_hash = false;
      if (strcmp (optarg, "sysv") == 0)
	link_info.emit_hash = true;
      else if (strcmp (optarg, "gnu") == 0)
	link_info.emit_gnu_hash = true;
      else if (strcmp (optarg, "both") == 0)
	{
	  link_info.emit_hash = true;
	  link_info.emit_gnu_hash = true;
	}
      else
	einfo (_("%F%P: invalid hash style `%s'\n"), optarg);
      break;

    case 'z':
      if (strcmp (optarg, "defs") == 0)
	link_info.unresolved_syms_in_objects = RM_DIAGNOSE;
      else if (strcmp (optarg, "undefs") == 0)
	link_info.unresolved_syms_in_objects = RM_IGNORE;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = true;
      else if (startswith (optarg, "max-page-size="))
	{
	  char *end;

	  link_info.maxpagesize = strtoul (optarg + 14, &end, 0);
	  if (*end
	      || (link_info.maxpagesize & (link_info.maxpagesize - 1)) != 0)
	    einfo (_("%F%P: invalid maximum page size `%s'\n"),
		   optarg + 14);
	  link_info.maxpagesize_is_set = true;
	}
      else if (startswith (optarg, "common-page-size="))
	{
	  char *end;
	  link_info.commonpagesize = strtoul (optarg + 17, &end, 0);
	  if (*end
	      || (link_info.commonpagesize & (link_info.commonpagesize - 1)) != 0)
	    einfo (_("%F%P: invalid common page size `%s'\n"),
		   optarg + 17);
	  link_info.commonpagesize_is_set = true;
	}
      else if (startswith (optarg, "stack-size="))
	{
	  char *end;
	  link_info.stacksize = strtoul (optarg + 11, &end, 0);
	  if (*end || link_info.stacksize < 0)
	    einfo (_("%F%P: invalid stack size `%s'\n"), optarg + 11);
	  if (!link_info.stacksize)
	    /* Use -1 for explicit no-stack, because zero means
	       'default'.   */
	    link_info.stacksize = -1;
	}
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = true;
	  link_info.noexecstack = false;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = true;
	  link_info.execstack = false;
	}
      else if (strcmp (optarg, "unique-symbol") == 0)
	link_info.unique_symbol = true;
      else if (strcmp (optarg, "nounique-symbol") == 0)
	link_info.unique_symbol = false;
      else if (strcmp (optarg, "globalaudit") == 0)
	{
	  link_info.flags_1 |= DF_1_GLOBAUDIT;
	}
      else if (startswith (optarg, "start-stop-gc"))
	link_info.start_stop_gc = true;
      else if (startswith (optarg, "nostart-stop-gc"))
	link_info.start_stop_gc = false;
      else if (startswith (optarg, "start-stop-visibility="))
	{
	  if (strcmp (optarg, "start-stop-visibility=default") == 0)
	    link_info.start_stop_visibility = STV_DEFAULT;
	  else if (strcmp (optarg, "start-stop-visibility=internal") == 0)
	    link_info.start_stop_visibility = STV_INTERNAL;
	  else if (strcmp (optarg, "start-stop-visibility=hidden") == 0)
	    link_info.start_stop_visibility = STV_HIDDEN;
	  else if (strcmp (optarg, "start-stop-visibility=protected") == 0)
	    link_info.start_stop_visibility = STV_PROTECTED;
	  else
	    einfo (_("%F%P: invalid visibility in `-z %s'; "
		     "must be default, internal, hidden, or protected"),
		   optarg);
	}
      else if (strcmp (optarg, "global") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_GLOBAL;
      else if (strcmp (optarg, "initfirst") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INITFIRST;
      else if (strcmp (optarg, "interpose") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INTERPOSE;
      else if (strcmp (optarg, "loadfltr") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_LOADFLTR;
      else if (strcmp (optarg, "nodefaultlib") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODEFLIB;
      else if (strcmp (optarg, "nodelete") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODELETE;
      else if (strcmp (optarg, "nodlopen") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NOOPEN;
      else if (strcmp (optarg, "nodump") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODUMP;
      else if (strcmp (optarg, "now") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 |= (bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "lazy") == 0)
	{
	  link_info.flags &= ~(bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 &= ~(bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "origin") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_ORIGIN;
	  link_info.flags_1 |= (bfd_vma) DF_1_ORIGIN;
	}
      else if (strcmp (optarg, "unique") == 0)
	link_info.gnu_flags_1 |= (bfd_vma) DF_GNU_1_UNIQUE;
      else if (strcmp (optarg, "nounique") == 0)
	link_info.gnu_flags_1 &= ~(bfd_vma) DF_GNU_1_UNIQUE;
      else if (strcmp (optarg, "combreloc") == 0)
	link_info.combreloc = true;
      else if (strcmp (optarg, "nocombreloc") == 0)
	link_info.combreloc = false;
      else if (strcmp (optarg, "nocopyreloc") == 0)
	link_info.nocopyreloc = true;
      else if (strcmp (optarg, "relro") == 0)
	link_info.relro = true;
      else if (strcmp (optarg, "norelro") == 0)
	link_info.relro = false;
      else if (strcmp (optarg, "separate-code") == 0)
	link_info.separate_code = true;
      else if (strcmp (optarg, "noseparate-code") == 0)
	link_info.separate_code = false;
      else if (strcmp (optarg, "common") == 0)
	link_info.elf_stt_common = elf_stt_common;
      else if (strcmp (optarg, "nocommon") == 0)
	link_info.elf_stt_common = no_elf_stt_common;
      else if (strcmp (optarg, "text") == 0)
	link_info.textrel_check = textrel_check_error;
      else if (strcmp (optarg, "notext") == 0)
	link_info.textrel_check = textrel_check_none;
      else if (strcmp (optarg, "textoff") == 0)
	link_info.textrel_check = textrel_check_none;
      else
	einfo (_("%P: warning: -z %s ignored\n"), optarg);
      break;
 
    case OPTION_INSN32:
      insn32 = true;
      break;

    case OPTION_NO_INSN32:
      insn32 = false;
      break;

    case OPTION_IGNORE_BRANCH_ISA:
      ignore_branch_isa = true;
      break;

    case OPTION_NO_IGNORE_BRANCH_ISA:
      ignore_branch_isa = false;
      break;

    case OPTION_COMPACT_BRANCHES:
      compact_branches = true;
      break;

    case OPTION_NO_COMPACT_BRANCHES:
      compact_branches = false;
      break;

    }

  return true;
}


static void
gldelf32ltsmip_list_options (FILE * file)
{
 
  fprintf (file, _("\
  --insn32                    Only generate 32-bit microMIPS instructions\n"
		   ));
  fprintf (file, _("\
  --no-insn32                 Generate all microMIPS instructions\n"
		   ));
  fprintf (file, _("\
  --ignore-branch-isa         Accept invalid branch relocations requiring\n\
                              an ISA mode switch\n"
		   ));
  fprintf (file, _("\
  --no-ignore-branch-isa      Reject invalid branch relocations requiring\n\
                              an ISA mode switch\n"
		   ));
  fprintf (file, _("\
  --compact-branches          Generate compact branches/jumps for MIPS R6\n"
		   ));
  fprintf (file, _("\
  --no-compact-branches       Generate delay slot branches/jumps for MIPS R6\n"
		   ));

}

struct ld_emulation_xfer_struct ld_elf32ltsmip_emulation =
{
  gldelf32ltsmip_before_parse,
  syslib_default,
  hll_default,
  ldelf_after_parse,
  gldelf32ltsmip_before_plugin_all_symbols_read,
  gldelf32ltsmip_after_open,
  after_check_relocs_default,
  ldelf_before_place_orphans,
  gldelf32ltsmip_after_allocation,
  ldelf_set_output_arch,
  ldemul_default_target,
  mips_before_allocation,
  gldelf32ltsmip_get_script,
  "elf32ltsmip",
  "elf32-tradlittlemips",
  finish_default,
  mips_create_output_section_statements,
  ldelf_open_dynamic_archive,
  ldelf_place_orphan,
  NULL,
  NULL,
  gldelf32ltsmip_add_options,
  gldelf32ltsmip_handle_option,
  NULL,
  gldelf32ltsmip_list_options,
  ldelf_load_symbols,
  NULL,
  NULL,
  NULL,
  ldelf_emit_ctf_early,
  ldelf_acquire_strings_for_ctf,
  ldelf_new_dynsym_for_ctf,
  NULL
};
